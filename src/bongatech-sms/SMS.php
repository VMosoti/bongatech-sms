<?php
/**
 * BongaTech SMS Client Library for PHP.
 *
 * @copyright Copyright (c) 2017
 * @author   Vincent Mosoti <vincent@vmosoti.com>
 * @license https://github.com/VMosoti/bongatech-sms/blob/master/LICENSE
 */

namespace VMosoti\BongaTech;

use VMosoti\BongaTech\Exceptions\BongaTechException;

/**
 * Class SMS
 */
class SMS
{
    /**
     * Version number of the SMS API.
     *
     * @var string
     */
    const VERSION = '1.0.0';

    /**
     * token is generated by md5(password).
     *
     * @var string
     */
    protected $token;

    /**
     * timestamp is the current datetime.
     *
     * @var string
     */
    protected $timestamp;

    /**
     * type of SMS to sent.
     *
     * @var int message
     */
    protected $message_type;

    /**
     * batch type of the SMS being sent.
     *
     * @var int batch
     */
    protected $batch_type;

    /**
     * sms configurations.
     *
     * @array config
     */
    protected $config;

    /**
     * end point url.
     *
     * @string endpoint
     */
    protected $endpoint;

    /**
     * the message being sent (array of messages in case message is different for each user.
     *
     * @var string/array.
     */
    protected $message;

    /**
     * the recipients .
     *
     * @var string/array.
     */
    protected $recipients;

    /**
     * SMS constructor.
     */
    public function __construct()
    {
        $this->config = Config::get();
        $this->setTimestamp();
        $this->setToken();
    }

    /**
     * set the timestamp.
     */
    private function setTimestamp()
    {
        $this->timestamp = date('YmdHis');
    }

    /**
     * set the token.
     */
    private function setToken()
    {
        $this->token = md5($this->config['password']);
    }

    /**
     * invoke if SMS being sent is of type subscribable.
     *
     * @return $this
     */
    public function messageTypeSubscribable()
    {
        $this->message_type = MessageType::SUBSCIBABLE;

        return $this;
    }

    /**
     * invoke if SMS being sent is of type on demand.
     *
     * @return $this
     */
    public function messageTypeOnDemand()
    {
        $this->message_type = MessageType::ON_DEMAND;

        return $this;
    }

    /**
     * invoke if SMS being sent is of type bulk SMS. This will be the common one.
     *
     * @return $this
     */
    public function messageTypeBulk()
    {
        $this->message_type = MessageType::BULK;

        return $this;
    }

    /**
     * invoke if SMS is being sent to a single recipient.
     *
     * @return $this
     */
    public function batchTypeNoBatch()
    {

        $this->batch_type = BatchType::NOT_BATCH;

        return $this;
    }

    /**
     * invoke if SMS is being sent to a different recipients.
     *
     * @return $this
     */
    public function batchTypeSameMessage()
    {
        $this->batch_type = BatchType::SAME_MESSAGE;

        return $this;
    }

    /**
     * invoke if each recipient will receive a different message.
     *
     * @return $this
     */
    public function batchTypeDifferentMessages()
    {
        $this->batch_type = BatchType::DIFFERENT_MESSAGE;

        return $this;
    }

    /**
     * @param $recipients
     * @param  $message
     * @throws BongaTechException
     * @return  string response
     */
    public function send($recipients, $message)
    {
        $this->recipients = $recipients;
        $this->message = $message;
        $this->endpoint = $this->config['base_url'] . $this->config['sms_endpoint'];
        $response = '';


        if ($this->batch_type === BatchType::NOT_BATCH) {

            $response = $this->sendForNoBatch();

        } elseif ($this->batch_type === BatchType::SAME_MESSAGE) {

        } elseif ($this->batch_type === BatchType::DIFFERENT_MESSAGE) {

        } else {

            throw new BongaTechException('Message Batch Type has not been set.');
        }

        return $response;

    }

    /**
     * send a message to a single recipient.
     *
     * @return Response
     */
    private function sendForNoBatch()
    {
        $headers = array(
            'Accept' => 'application/json'
        );

        $body = array(
            'AuthDetails' => array(
                array(
                    'UserID' => $this->config['user_id'],
                    'Token' => $this->token,
                    'Timestamp' => $this->timestamp

                )
            ),
            'MessageType' => array(
                (string)$this->message_type
            ),
            'BatchType' => array(
                (string)$this->batch_type
            ),
            'SourceAddr' => array(
                (string)$this->config['sender_id']
            ),
            'MessagePayload' => array(
                array(
                    'Text' => $this->message
                )
            ),
            'DestinationAddr' => array(
                array(
                    'MSISDN' => $this->recipients,
                    'LinkID' => '',
                    'SourceID' => rand(2, 9)
                )
            ),
            'DeliveryRequest' => array(
                array(
                    'EndPoint' => $this->config['callback_url'],
                    'Correlator' => mt_rand()
                )
            )
        );

        $request = new Request($this->endpoint, $headers, $body);
        $response = $request->send();

        return new Response($response->body[0]);

    }

    /**
     * send same message to different recipients.
     *
     * @param Request $request
     * @return request
     */
    private function sendForSameMessage(Request $request)
    {
        return $request;
    }

    /**
     * send different message to different recipients.
     *
     * @param Request $request
     */
    private function sendForDifferentMessages(Request $request)
    {
    }

    public static function getBalance()
    {

        $config = Config::get();

        $endpoint = $config['base_url'] . $config['balance_endpoint'] . '?UserID=' . $config['user_id'] . '&Token=' . md5($config['password']);

        $request = new Request($endpoint);
        $response = $request->getBalance();

        return new Response($response->body);
    }


}
