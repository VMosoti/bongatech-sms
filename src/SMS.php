<?php
/**
 * BongaTech SMS Client Library for PHP.
 *
 * @copyright Copyright (c) 2017
 * @author   Vincent Mosoti <vincent@vmosoti.com>
 * @license https://github.com/VMosoti/bongatech-sms/blob/master/LICENSE
 */

namespace VMosoti\BongaTech;

use VMosoti\BongaTech\Exceptions\BongaTechException;

/**
 * Class SMS.
 */
class SMS
{
    /**
     * Version number of the SMS API.
     *
     * @var string
     */
    const VERSION = '2.0.0';

    /**
     * Base URL.
     *
     * @var string
     */
    const BASE_URL = 'http://197.248.4.47/smsapi/';

    /**
     * Send SMS endpoint.
     *
     * @var string
     */
    const SMS_ENDPOINT = 'submit.php';

    /**
     * Get Balance endpoint.
     *
     * @var string
     */
    const GET_BALANCE_ENDPOINT = 'balance.php';

    /**
     * token is generated by md5(password).
     *
     * @var string
     */
    protected $token;

    /**
     * timestamp is the current datetime.
     *
     * @var string
     */
    protected $timestamp;

    /**
     * type of SMS to sent.
     *
     * @var int message
     */
    protected $message_type = 0;

    /**
     * batch type of the SMS being sent.
     *
     * @var int batch
     */
    protected $batch_type;

    /**
     * sms configurations.
     *
     * @array config
     */
    protected $config;

    /**
     * end point url.
     *
     * @string endpoint
     */
    protected $endpoint;

    /**
     * the message(s) being sent (array of messages in case message is different for each user.
     *
     * @var array.
     */
    protected $message;

    /**
     * the recipients .
     *
     * @var array.
     */
    protected $recipients;

    /**
     * SMS constructor.
     */
    public function __construct()
    {
        $this->config = Config::get();

        if (
            empty($this->config['user_id']) ||
            empty($this->config['password']) ||
            empty($this->config['sender_id'])
        ){
            throw new BongaTechException('Please ensure that all configuration variables have been set.');
        }

        $this->setTimestamp();
        $this->setToken();
    }

    /**
     * set the timestamp.
     */
    private function setTimestamp()
    {
        $this->timestamp = date('YmdHis');
    }

    /**
     * set the token.
     */
    private function setToken()
    {
        $this->token = md5($this->config['password']);
    }

    /**
     * invoke if SMS being sent is of type subscribable.
     *
     * @return $this
     */
    public function subscribable()
    {
        $this->message_type = MessageType::SUBSCIBABLE;

        return $this;
    }

    /**
     * invoke if SMS being sent is of type on demand.
     *
     * @return $this
     */
    public function onDemand()
    {
        $this->message_type = MessageType::ON_DEMAND;

        return $this;
    }

    /**
     * invoke if SMS being sent is of type bulk SMS. This will be the common one.
     *
     * @return $this
     */
    public function bulk()
    {
        $this->message_type = MessageType::BULK;

        return $this;
    }

    /**
     * invoke if SMS is being sent to a single recipient.
     *
     * @return $this
     */
    public function toOne()
    {
        $this->batch_type = BatchType::NOT_BATCH;

        return $this;
    }

    /**
     * invoke if SMS is being sent to a different recipients, or if each recipient receives custom sms.
     *
     * @return $this
     */
    public function toMany()
    {
        $this->batch_type = BatchType::BATCH;

        return $this;
    }

    /**
     * @param $recipients
     * @param  $message
     *
     * @throws BongaTechException
     *
     * @return mixed
     */
    public function send($recipients, $message)
    {
        $this->recipients = $recipients;
        $this->message = $message;
        $this->endpoint = self::BASE_URL.self::SMS_ENDPOINT;

        if ($this->batch_type === BatchType::NOT_BATCH) {
            if (is_array($this->message) && array_depth($this->message) == 2 && count($this->message) == 1) {
                if (is_array($this->recipients) && array_depth($this->recipients) == 2 && count($this->recipients) == 1) {
                    $response = $this->sendForNonBatch($this->buildSendObject($this->recipients, $this->message));
                } else {
                    throw new BongaTechException('The recipient MUST be an array of depth 2 and count should not be more than 1');
                }
            } else {
                throw new BongaTechException('Message should be provided as an array whose depth is 2 and count should equal 1');
            }
        } elseif ($this->batch_type === BatchType::BATCH) {
            if (is_array($this->message) && array_depth($this->message) == 2 && count($this->message) > 0) {
                if (is_array($this->recipients) && array_depth($this->recipients) == 2 && count($this->recipients) > 1) {
                    $response = $this->sendForBatch($this->buildSendObject($this->recipients, $this->message));
                } else {
                    throw new BongaTechException('The recipients MUST be an array of depth 2 and count should be more than 1');
                }
            } else {
                throw new BongaTechException('Message should be provided as an array whose depth should be 2');
            }
        } else {
            throw new BongaTechException('Message Batch Type has not been set.');
        }

        return $response;
    }

    /**
     * build the send object.
     *
     * @param  recipients
     * @param $messages
     *
     * @return array
     */
    private function buildSendObject($recipients, $messages)
    {
        $body = [
            'AuthDetails' => [
                [
                    'UserID'    => $this->config['user_id'],
                    'Token'     => $this->token,
                    'Timestamp' => $this->timestamp,

                ],
            ],
            'MessageType' => [
                (string) $this->message_type,
            ],
            'BatchType' => [
                (string) $this->batch_type,
            ],
            'SourceAddr' => [
                (string) $this->config['sender_id'],
            ],
            'MessagePayload'  => $messages,
            'DestinationAddr' => $recipients,
            'DeliveryRequest' => [
                [
                    'EndPoint'   => $this->config['callback_url'],
                    'Correlator' => (string) mt_rand(),
                ],
            ],
        ];

        return $body;
    }

    /**
     * send a message to a single recipient.
     *
     * @param $body
     *
     * @return Response
     */
    private function sendForNonBatch($body)
    {
        $request = new Request($this->endpoint, $body);
        $response = $request->sendSMS();

        return new Response($response->body[0]);
    }

    /**
     * send batch. 1) same message to many recipients 2) different messages to many recipients.
     *
     * @param $body
     *
     * @return array
     */
    private function sendForBatch($body)
    {
        $request = new Request($this->endpoint, $body);
        $response = $request->sendSMS();

        $responses = [];
        $response_count = count($response->body);

        for ($i = 0; $i < $response_count; $i++) {
            $res = new Response($response->body[$i]);
            $responses[] = $res;
        }

        return $responses;
    }

    public static function getBalance()
    {
        $config = Config::get();

        $endpoint = self::BASE_URL.self::GET_BALANCE_ENDPOINT.'?UserID='.$config['user_id'].'&Token='.md5($config['password']);

        $request = new Request($endpoint);
        $response = $request->getBalance();

        return new Response($response->body);
    }
}
